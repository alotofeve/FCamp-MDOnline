/*
*  "#" ===> optional
*/


AppointmentController:

Create:
/POST "/createAppointment"
INPUT{
  Departmet: String
  Date:String
  DoctorName: String
  DoctorID: Int
  Description: String
}
OUTUT{
  isCreated: Boolean
}

Cancel:
/POST "/cancelAppointment"
INPUT{
  Departmet: String
  Date:String
  DoctorName: String
  Description: String
}
OUTPUT{
  isCancelled:
}


# FCamp-MDOnline

Appointment feature:

1.Controller:
定义一个名为AppointmentController的class 包括以下方法：

//create一个新的available appointment
POST /appointment
void createAppointment(@RequestBody Appointment body)
requestbody中可以传入{doctorID:12, scheduledDate:2023-03-01 15:30:00}
然后通过call appointmentService.createAppointment()

//如果不小心创建错误可以及时删除appointment
DELETE /appointment/{appointment_id}
void deleteAppointment(@RequestParam("appointment_id") Long id)
然后call appointmentService.deleteAppointmentById()

//当患者点预约时可以将这个appointment的status更新成booked， 当患者点取消时可以status更新成available
PUT /appointment/{id}/{status}
void updateAppointment(@RequestParam("id") Long appointmentId, @RequestParam("status") String status，@AuthenticationPrincipal User patient)
然后call appointmentService.updateAppointmentStatus(appointmentId, status, patient)

//当患者或医生登入后可以看到自己ongoing或past的预约信息（对应的是BookedAppointment table）
GET /bookedAppointments
List<BookedAppointment> getBookedAppointments(@AuthenticationPrincipal User user）
然后call appointmentService.getBookedAppointments(user)

//希望医生登入系统后可以看到已经被book的appointment以及相关的患者信息
UPDATE /bookedAppointments/{id}
void updateBookedAppointments(@RequestParam("id") Long id) 
然后call appointmentService.updateBookedAppointments(id)

2. Service

定义一个名为AppointmentService的class 包括以下方法：

a. void createAppointment(String doctorID, Date date)
method body：Record newAppointment = new Appointment(doctorID,date, ...,"available")
	     依赖于AppointmentRepository interface 用其中的save method将newAppointment存入

b. void deleteAppointment(Long id)
method body: 依赖于AppointmentRepository interface 用其中的deleteById method将这个appointment删除

c. void updateAppointmentStatus(Long appointmentID, String status)
method body: 依赖于AppointmentRepository interface 用其中的updateStatusByAppointmentID method将这个appointment的status update成booked or available

根据status的值判断：
如果status是booked 那么有了新的预约需要在BookedAppointment中插入一条新数据 先new一个BookedAppointment 然后call BookedAppointmentRepository interface中的save方法
如果status是available 那么需要取消当前预约需要在BookedAppointment中删除一条新数据 需要call BookedAppointmentRepository interface中的deleteByAppointmentId方法

d. List<BookedAppointment> getBookedAppointments(user)
method body: 先判断user是否是医生 

是医生
依赖于BookedAppointmentRepository interface 用getOngoingBookedAppointmentsByDoctorID method来获取这个医生ongoing的预约
用getPastBookedAppointmentsByDoctorID method来获取这个医生past的预约历史

是患者
依赖于BookedAppointmentRepository interface 用getOngoingBookedAppointmentsByPatientID method来获取这个患者ongoing的预约
用getPastBookedAppointmentsByPatientID method来获取这个患者past的预约历史

e.void updateBookedAppointments(id)

依赖于BookedAppointmentRepository interface 用updateBookedAppointmentById method来更新status field to "past"(past代表已经完成的预约  ongoing代表还没有来问诊）



3.Repository

定义一个名为AppointmentRepository的interface
    public interface AppointmentRepository extends ListCrudRepository<AppointmentEntity, Long>有以下方法
	save 
	deleteById
	void updateStatusByAppointmentID(String status, Long id)（用@Modifying @Query自己写个sql） 

定义一个名为BookedAppointmentRepository的interface
    public interface BookedAppointmentRepository extends ListCrudRepository<BookedAppointmentEntity, Long>有以下方法
	List<BookedAppointment> getOngoingBookedAppointmentsByDoctorID
	List<BookedAppointment> getPastBookedAppointmentsByDoctorID
	List<BookedAppointment> getOngoingBookedAppointmentsByPatientID 
	List<BookedAppointment> getPastBookedAppointmentsByPatientID 
	void updateBookedAppointmentById
	void deleteByAppointmentId 
	save
	

 


4. Record

public record AppointmentEntity(
        @Id Long id,
        String doctorID,
        Date   date,
	String  status

) {
}

public record BookedAppointmentEntity(
	@Id Long id,
        Doctor doctor,
	Patient patientID,
	Appointment appointmentID,
	String  status
){}





